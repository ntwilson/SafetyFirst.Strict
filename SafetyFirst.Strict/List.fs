module List

/// <summary>
/// Returns the average of the elements in the list.
/// Throws if <c>source</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.averageSafe or List.average' instead.", 12101, IsHidden=true, IsError=false)>]
let inline average source = List.average source 

/// <summary>
/// Returns the average of the results generated by applying the function to each element
/// of the list.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.averageBySafe or List.averageBy' instead.", 12101, IsHidden=true, IsError=false)>]
let inline averageBy selector xs = List.averageBy selector xs

/// <summary>
/// Divides the input list into chunks of size at most <c>size</c>.
/// Throws if the <c>size</c> is less than zero.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.chunkBySize' or List.chunksOf instead.", 12101, IsHidden=true, IsError=false)>]
let inline chunkBySize size xs = List.chunkBySize size xs

/// <summary>
/// If the input list has only one element, returns that element.
/// Throws if the input list has more or less than one element.  
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.exactlyOneSafe or List.exactlyOne' instead.", 12101, IsHidden=true, IsError=false)>]
let inline exactlyOne xs = List.exactlyOne xs

/// <summary>
/// Returns the first element for which the given function returns True.
/// Throws if no such element is found.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.findSafe or List.find' instead.", 12101, IsHidden=true, IsError=false)>]
let inline find predicate xs = List.find predicate xs

/// <summary>
/// Returns the last element for which the given function returns True.
/// Throws if no such element exists.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.findBackSafe or List.findBack' instead.", 12101, IsHidden=true, IsError=false)>]
let inline findBack predicate xs = List.findBack predicate xs

/// <summary>
/// Returns the index of the first element in the list
/// that satisfies the given predicate.
/// Throws if no such element exists.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.findIndexSafe or List.findIndex' instead.", 12101, IsHidden=true, IsError=false)>]
let inline findIndex predicate xs = List.findIndex predicate xs

/// <summary>
/// Returns the index of the last element in the list
/// that satisfies the given predicate.
/// Throws if no such element exists.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.findIndexBackSafe or List.findIndexBack' instead.", 12101, IsHidden=true, IsError=false)>]
let inline findIndexBack predicate xs = List.findIndexBack predicate xs

/// <summary>
/// Applies a function to corresponding elements of two collections, threading an accumulator argument
/// through the computation. The collections must have identical sizes.
/// If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jN</c>
/// then computes <c>f (... (f s i0 j0)...) iN jN</c>.
/// Throws if the input lists have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.fold2Safe or List.fold2' instead.", 12101, IsHidden=true, IsError=false)>]
let inline fold2 folder initialState xs ys = List.fold2 folder initialState xs ys

/// <summary>
/// Applies a function to corresponding elements of two collections, threading an accumulator argument
/// through the computation. The collections must have identical sizes.
/// If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jN</c>
/// then computes <c>f i0 j0 (...(f iN jN s))</c>.
/// Throws if the input lists have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.foldBack2Safe or List.foldBack2' instead.", 12101, IsHidden=true, IsError=false)>]
let inline foldBack2 folder xs ys initialState = List.foldBack2 folder xs ys initialState

/// <summary>
/// Tests if all corresponding elements of the list satisfy the given predicate pairwise.
/// Throws if the input lists have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.forall2Safe or List.forall2' instead.", 12101, IsHidden=true, IsError=false)>]
let inline forall2 predicate xs ys = List.forall2 predicate xs ys

/// <summary>
/// Returns the first element of the list.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.headSafe or List.head' instead.", 12101, IsHidden=true, IsError=false)>]
let inline head xs = List.head xs

/// <summary>
/// Computes the element at the specified index in the collection.
/// Throws if the index is negative or exceeds the size of the collection.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.itemSafe or List.item' instead.", 12101, IsHidden=true, IsError=false)>]
let inline item index xs = List.item index xs

/// <summary>
/// Applies the given function to two collections simultaneously. The collections must have identical size.
/// Throws if the input lists have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.iter2Safe or List.iter2' instead.", 12101, IsHidden=true, IsError=false)>]
let inline iter2 action xs ys = List.iter2 action xs ys

/// <summary>
/// Applies the given function to two collections simultaneously. The
/// collections must have identical size. The integer passed to the
/// function indicates the index of element.
/// Throws if the input lists have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.iteri2Safe or List.iteri2' instead.", 12101, IsHidden=true, IsError=false)>]
let inline iteri2 action xs ys = List.iteri2 action xs ys 

/// <summary>
/// Returns the last element of the list.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.lastSafe or List.last' instead.", 12101, IsHidden=true, IsError=false)>]
let inline last xs = List.last xs

/// <summary>
/// Builds a new collection whose elements are the results of applying the given function
/// to the corresponding elements of the two collections pairwise.
/// Throws if the input lists have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.map2Safe or List.map2' instead.", 12101, IsHidden=true, IsError=false)>]
let inline map2 f xs ys = List.map2 f xs ys

/// <summary>
/// Like mapi, but mapping corresponding elements from two lists of equal length.
/// Throws if the input lists have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.mapi2Safe or List.mapi2' instead.", 12101, IsHidden=true, IsError=false)>]
let inline mapi2 f xs ys = List.mapi2 f xs ys

/// <summary>
/// Builds a new collection whose elements are the results of applying the given function
/// to the corresponding elements of the three collections simultaneously.
/// Throws if the input lists have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.map3Safe or List.map3' instead.", 12101, IsHidden=true, IsError=false)>]
let inline map3 f xs ys zs = List.map3 f xs ys zs

/// <summary>
/// Returns the greatest of all elements of the list, compared via Operators.max.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.maxSafe or List.max' instead.", 12101, IsHidden=true, IsError=false)>]
let inline max<'a when 'a : comparison> (xs:'a list) = List.max xs

/// <summary>
/// Returns the greatest of all elements of the list, compared via Operators.max on the function result.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.maxBySafe or List.maxBy' instead.", 12101, IsHidden=true, IsError=false)>]
let inline maxBy<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs:'a list) = List.maxBy projection xs

/// <summary>
/// Returns the lowest of all elements of the list, compared via Operators.min.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.minSafe or List.min' instead.", 12101, IsHidden=true, IsError=false)>]
let inline min<'a when 'a : comparison> (xs:'a list) = List.min xs

/// <summary>
/// Returns the lowest of all elements of the list, compared via Operators.min on the function result.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.minBySafe or List.minBy' instead.", 12101, IsHidden=true, IsError=false)>]
let inline minBy<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs:'a list) = List.minBy projection xs

/// <summary>
/// Applies the given function to successive elements, returning the first
/// result where the function returns "Some(x)".
/// Throws if no such element exists.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.pickSafe or List.pick' instead.", 12101, IsHidden=true, IsError=false)>]
let inline pick chooser xs = List.pick chooser xs

/// <summary>
/// Applies a function to each element of the list, threading an accumulator argument
/// through the computation. Begin by applying the function to the first two elements.
/// Then feed this result into the function along with the third element and so on.
/// Return the final result.
/// Throws if the list is empty.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.reduce' or List.fold instead.", 12101, IsHidden=true, IsError=false)>]
let inline reduce reduction xs = List.reduce reduction xs

/// <summary>
/// Applies a function to each element of the list, starting from the end, threading an accumulator argument
/// through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c>
/// then computes <c>f i0 (...(f iN-1 iN))</c>.
/// Throws if the list is empty.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.reduceBack' or List.foldBack instead.", 12101, IsHidden=true, IsError=false)>]
let inline reduceBack reduction xs = List.reduceBack reduction xs 

/// <summary>
/// Returns a list that skips N elements of the underlying list and then yields the
/// remaining elements of the list.
/// Throws if <c>count</c> exceeds the length of <c>xs</c> 
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.skip' or List.skipLenient instead.", 12101, IsHidden=true, IsError=false)>]
let inline skip count xs = List.skip count xs

/// <summary>
/// Splits a list into two lists, at the given index.
/// Throws when split index exceeds 
/// the number of elements in the list.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.splitAtSafe or List.splitAt' instead.", 12101, IsHidden=true, IsError=false)>]
let inline splitAt index xs = List.splitAt index xs 

/// <summary>
/// Splits the input list into at most count chunks.
/// Throws if <c>count</c> is not positive.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.splitInto' or List.splitIntoN instead.", 12101, IsHidden=true, IsError=false)>]
let inline splitInto count xs = List.splitInto count xs

/// <summary>
/// Returns a list that skips 1 element of the underlying list and then yields the
/// remaining elements of the list.
/// Throws if <c>xs</c> contains no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.tailSafe or List.tail' instead.", 12101, IsHidden=true, IsError=false)>]
let inline tail xs = List.tail xs

/// <summary>
/// Returns the first N elements of the list.
/// Throws if <c>count</c> exceeds the length of <c>xs</c> 
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.take' or List.truncate instead.", 12101, IsHidden=true, IsError=false)>]
let inline take count xs = List.take count xs

/// <summary>
/// Returns a list that yields sliding windows containing elements drawn from the input
/// list. Each window is returned as a fresh list.
/// Throws when <c>size</c> is not positive.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.windowed' or List.window instead.", 12101, IsHidden=true, IsError=false)>]
let inline windowed size xs = List.windowed size xs

/// <summary>
/// Combines the two lists into a list of pairs. The two lists must have equal lengths.
/// Throws if the input lists have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.zipSafe or List.zip' instead.", 12101, IsHidden=true, IsError=false)>]
let inline zip xs ys = List.zip xs ys

/// <summary>
/// Combines the three lists into a list of triples. The lists must have equal lengths.
/// Throws if the input lists have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use List.zip3Safe or List.zip3' instead.", 12101, IsHidden=true, IsError=false)>]
let inline zip3 xs ys zs = List.zip3 xs ys zs

// //TODO: transpose, split once we use a newer FSharp.Core


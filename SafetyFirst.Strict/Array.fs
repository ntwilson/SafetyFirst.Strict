module Array


/// <summary>
/// Returns the average of the elements in the array.
/// Throws if <c>source</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.averageSafe or Array.average' instead.", 12101, IsHidden=true, IsError=false)>]
let inline average source = Array.average source 

/// <summary>
/// Returns the average of the results generated by applying the function to each element
/// of the array.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.averageBySafe or Array.averageBy' instead.", 12101, IsHidden=true, IsError=false)>]
let inline averageBy selector xs = Array.averageBy selector xs

/// <summary>
/// Divides the input array into chunks of size at most <c>size</c>.
/// Throws if the <c>size</c> is less than zero.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.chunkBySize' or Array.chunksOf instead.", 12101, IsHidden=true, IsError=false)>]
let inline chunkBySize size xs = Array.chunkBySize size xs

/// <summary>
/// If the input array has only one element, returns that element.
/// Throws if the input array has more or less than one element.  
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.exactlyOneSafe or Array.exactlyOne' instead.", 12101, IsHidden=true, IsError=false)>]
let inline exactlyOne xs = Array.exactlyOne xs

/// <summary>
/// Returns the first element for which the given function returns True.
/// Throws if no such element is found.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.findSafe or Array.find' instead.", 12101, IsHidden=true, IsError=false)>]
let inline find predicate xs = Array.find predicate xs

/// <summary>
/// Returns the last element for which the given function returns True.
/// Throws if no such element exists.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.findBackSafe or Array.findBack' instead.", 12101, IsHidden=true, IsError=false)>]
let inline findBack predicate xs = Array.findBack predicate xs

/// <summary>
/// Returns the index of the first element in the array
/// that satisfies the given predicate.
/// Throws if no such element exists.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.findIndexSafe or Array.findIndex' instead.", 12101, IsHidden=true, IsError=false)>]
let inline findIndex predicate xs = Array.findIndex predicate xs

/// <summary>
/// Returns the index of the last element in the array
/// that satisfies the given predicate.
/// Throws if no such element exists.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.findIndexBackSafe or Array.findIndexBack' instead.", 12101, IsHidden=true, IsError=false)>]
let inline findIndexBack predicate xs = Array.findIndexBack predicate xs

/// <summary>
/// Applies a function to corresponding elements of two collections, threading an accumulator argument
/// through the computation. The collections must have identical sizes.
/// If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jN</c>
/// then computes <c>f (... (f s i0 j0)...) iN jN</c>.
/// Throws if the input arrays have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.fold2Safe or Array.fold2' instead.", 12101, IsHidden=true, IsError=false)>]
let inline fold2 folder initialState xs ys = Array.fold2 folder initialState xs ys

/// <summary>
/// Applies a function to corresponding elements of two collections, threading an accumulator argument
/// through the computation. The collections must have identical sizes.
/// If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jN</c>
/// then computes <c>f i0 j0 (...(f iN jN s))</c>.
/// Throws if the input arrays have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.foldBack2Safe or Array.foldBack2' instead.", 12101, IsHidden=true, IsError=false)>]
let inline foldBack2 folder xs ys initialState = Array.foldBack2 folder xs ys initialState

/// <summary>
/// Tests if all corresponding elements of the array satisfy the given predicate pairwise.
/// Throws if the input arrays have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.forall2Safe or Array.forall2' instead.", 12101, IsHidden=true, IsError=false)>]
let inline forall2 predicate xs ys = Array.forall2 predicate xs ys

/// <summary>
/// Returns the first element of the array.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.headSafe or Array.head' instead.", 12101, IsHidden=true, IsError=false)>]
let inline head xs = Array.head xs

/// <summary>
/// Computes the element at the specified index in the collection.
/// Throws if the index is negative or exceeds the size of the collection.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.itemSafe or Array.item' instead.", 12101, IsHidden=true, IsError=false)>]
let inline item index xs = Array.item index xs

/// <summary>
/// Applies the given function to two collections simultaneously. The collections must have identical size.
/// Throws if the input arrays have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.iter2Safe or Array.iter2' instead.", 12101, IsHidden=true, IsError=false)>]
let inline iter2 action xs ys = Array.iter2 action xs ys

/// <summary>
/// Applies the given function to two collections simultaneously. The
/// collections must have identical size. The integer passed to the
/// function indicates the index of element.
/// Throws if the input arrays have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.iteri2Safe or Array.iteri2' instead.", 12101, IsHidden=true, IsError=false)>]
let inline iteri2 action xs ys = Array.iteri2 action xs ys 

/// <summary>
/// Returns the last element of the array.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.lastSafe or Array.last' instead.", 12101, IsHidden=true, IsError=false)>]
let inline last xs = Array.last xs

/// <summary>
/// Builds a new collection whose elements are the results of applying the given function
/// to the corresponding elements of the two collections pairwise.
/// Throws if the input arrays have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.map2Safe or Array.map2' instead.", 12101, IsHidden=true, IsError=false)>]
let inline map2 f xs ys = Array.map2 f xs ys

/// <summary>
/// Like mapi, but mapping corresponding elements from two arrays of equal length.
/// Throws if the input arrays have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.mapi2Safe or Array.mapi2' instead.", 12101, IsHidden=true, IsError=false)>]
let inline mapi2 f xs ys = Array.mapi2 f xs ys

/// <summary>
/// Builds a new collection whose elements are the results of applying the given function
/// to the corresponding elements of the three collections simultaneously.
/// Throws if the input arrays have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.map3Safe or Array.map3' instead.", 12101, IsHidden=true, IsError=false)>]
let inline map3 f xs ys zs = Array.map3 f xs ys zs

/// <summary>
/// Returns the greatest of all elements of the array, compared via Operators.max.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.maxSafe or Array.max' instead.", 12101, IsHidden=true, IsError=false)>]
let inline max<'a when 'a : comparison> (xs:'a array) = Array.max xs

/// <summary>
/// Returns the greatest of all elements of the array, compared via Operators.max on the function result.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.maxBySafe or Array.maxBy' instead.", 12101, IsHidden=true, IsError=false)>]
let inline maxBy<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs:'a array) = Array.maxBy projection xs

/// <summary>
/// Returns the lowest of all elements of the array, compared via Operators.min.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.minSafe or Array.min' instead.", 12101, IsHidden=true, IsError=false)>]
let inline min<'a when 'a : comparison> (xs:'a array) = Array.min xs

/// <summary>
/// Returns the lowest of all elements of the array, compared via Operators.min on the function result.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.minBySafe or Array.minBy' instead.", 12101, IsHidden=true, IsError=false)>]
let inline minBy<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs:'a array) = Array.minBy projection xs

/// <summary>
/// Applies the given function to successive elements, returning the first
/// result where the function returns "Some(x)".
/// Throws if no such element exists.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.pickSafe or Array.pick' instead.", 12101, IsHidden=true, IsError=false)>]
let inline pick chooser xs = Array.pick chooser xs

/// <summary>
/// Applies a function to each element of the array, threading an accumulator argument
/// through the computation. Begin by applying the function to the first two elements.
/// Then feed this result into the function along with the third element and so on.
/// Return the final result.
/// Throws if the array is empty.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.reduce' or Array.fold instead.", 12101, IsHidden=true, IsError=false)>]
let inline reduce reduction xs = Array.reduce reduction xs

/// <summary>
/// Applies a function to each element of the array, starting from the end, threading an accumulator argument
/// through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c>
/// then computes <c>f i0 (...(f iN-1 iN))</c>.
/// Throws if the array is empty.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.reduceBack' or Array.foldBack instead.", 12101, IsHidden=true, IsError=false)>]
let inline reduceBack reduction xs = Array.reduceBack reduction xs 

/// <summary>
/// Returns an array that skips N elements of the underlying array and then yields the
/// remaining elements of the array.
/// Throws if <c>count</c> exceeds the length of <c>xs</c> 
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.skip' or Array.skipLenient instead.", 12101, IsHidden=true, IsError=false)>]
let inline skip count xs = Array.skip count xs

/// <summary>
/// Splits an array into two arrays, at the given index.
/// Throws when split index exceeds 
/// the number of elements in the array.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.splitAtSafe or Array.splitAt' instead.", 12101, IsHidden=true, IsError=false)>]
let inline splitAt index xs = Array.splitAt index xs 

/// <summary>
/// Splits the input array into at most count chunks.
/// Throws if <c>count</c> is not positive.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.splitInto' or Array.splitIntoN instead.", 12101, IsHidden=true, IsError=false)>]
let inline splitInto count xs = Array.splitInto count xs

/// <summary>
/// Slices an array given a starting index and a count of elements to return.
/// Throws if either <c>startIndex</c> or <c>count</c> is negative,
/// or if there aren't enough elements in the input array.
/// (This is computed if the <c>startIndex</c> + the <c>count</c> is greater
/// than the length of the array.  Note that it returns an empty array if <c>startIndex</c>
/// is equal to the length of the array and the <c>count</c> is 0.)
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.subSafe or Array.sub' instead.", 12101, IsHidden=true, IsError=false)>]
let inline sub xs startIndex count = Array.sub xs startIndex count

/// <summary>
/// Returns an array that skips 1 element of the underlying array and then yields the
/// remaining elements of the array.
/// Throws if <c>xs</c> contains no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.tailSafe or Array.tail' instead.", 12101, IsHidden=true, IsError=false)>]
let inline tail xs = Array.tail xs

/// <summary>
/// Returns the first N elements of the array.
/// Throws if <c>count</c> exceeds the length of <c>xs</c> 
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.take' or Array.truncate instead.", 12101, IsHidden=true, IsError=false)>]
let inline take count xs = Array.take count xs

/// <summary>
/// Returns an array that yields sliding windows containing elements drawn from the input
/// array. Each window is returned as a fresh array.
/// Throws when <c>size</c> is not positive.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.windowed' or Array.window instead.", 12101, IsHidden=true, IsError=false)>]
let inline windowed size xs = Array.windowed size xs

/// <summary>
/// Combines the two arrays into an array of pairs. The two arrays must have equal lengths.
/// Throws if the input arrays have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.zipSafe or Array.zip' instead.", 12101, IsHidden=true, IsError=false)>]
let inline zip xs ys = Array.zip xs ys

/// <summary>
/// Combines the three arrays into an array of triples. The arrays must have equal lengths.
/// Throws if the input arrays have a different number of elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Array.zip3Safe or Array.zip3' instead.", 12101, IsHidden=true, IsError=false)>]
let inline zip3 xs ys zs = Array.zip3 xs ys zs

// //TODO: transpose, split once we use a newer FSharp.Core


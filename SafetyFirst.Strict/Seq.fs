module Seq

/// <summary>
/// Returns the average of the elements in the sequence.
/// Throws if <c>source</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.averageSafe or Seq.average' instead.", 12101, IsHidden=true, IsError=false)>]
let inline average source = Seq.average source

/// <summary>
/// Returns the average of the results generated by applying the function to each element
/// of the seq.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.averageBySafe or Seq.averageBy' instead.", 12101, IsHidden=true, IsError=false)>]
let inline averageBy selector xs = Seq.averageBy selector xs

/// <summary>
/// Divides the input seq into chunks of size at most <c>size</c>.
/// Throws if the <c>size</c> is less than zero.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.chunkBySize' or Seq.chunksOf instead.", 12101, IsHidden=true, IsError=false)>]
let inline chunkBySize size xs = Seq.chunkBySize size xs

/// <summary>
/// If the input seq has only one element, returns that element.
/// Throws if the input seq has more or less than one element.  
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.exactlyOneSafe or Seq.exactlyOne' instead.", 12101, IsHidden=true, IsError=false)>]
let inline exactlyOne xs = Seq.exactlyOne xs

/// <summary>
/// Returns the first element for which the given function returns True.
/// Throws if no such element is found.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.findSafe or Seq.find' instead.", 12101, IsHidden=true, IsError=false)>]
let inline find predicate xs = Seq.find predicate xs

/// <summary>
/// Returns the last element for which the given function returns True.
/// Throws if no such element exists.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.findBackSafe or Seq.findBack' instead.", 12101, IsHidden=true, IsError=false)>]
let inline findBack predicate xs = Seq.findBack predicate xs

/// <summary>
/// Returns the index of the first element in the seq
/// that satisfies the given predicate.
/// Throws if no such element exists.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.findIndexSafe or Seq.findIndex' instead.", 12101, IsHidden=true, IsError=false)>]
let inline findIndex predicate xs = Seq.findIndex predicate xs

/// <summary>
/// Returns the index of the last element in the seq
/// that satisfies the given predicate.
/// Throws if no such element exists.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.findIndexBackSafe or Seq.findIndexBack' instead.", 12101, IsHidden=true, IsError=false)>]
let inline findIndexBack predicate xs = Seq.findIndexBack predicate xs

/// <summary>
/// Returns the first element of the seq.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.headSafe or Seq.head' instead.", 12101, IsHidden=true, IsError=false)>]
let inline head xs = Seq.head xs

/// <summary>
/// Computes the element at the specified index in the collection.
/// Throws if the index is negative or exceeds the size of the collection.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.itemSafe or Seq.item' instead.", 12101, IsHidden=true, IsError=false)>]
let inline item index xs = Seq.item index xs

/// <summary>
/// Returns the last element of the seq.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.lastSafe or Seq.last' instead.", 12101, IsHidden=true, IsError=false)>]
let inline last xs = Seq.last xs

/// <summary>
/// Returns the greatest of all elements of the seq, compared via Operators.max.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.maxSafe or Seq.max' instead.", 12101, IsHidden=true, IsError=false)>]
let inline max<'a when 'a : comparison> (xs:'a seq) = Seq.max xs

/// <summary>
/// Returns the greatest of all elements of the seq, compared via Operators.max on the function result.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.maxBySafe or Seq.maxBy' instead.", 12101, IsHidden=true, IsError=false)>]
let inline maxBy<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs:'a seq) = Seq.maxBy projection xs

/// <summary>
/// Returns the lowest of all elements of the seq, compared via Operators.min.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.minSafe or Seq.min' instead.", 12101, IsHidden=true, IsError=false)>]
let inline min<'a when 'a : comparison> (xs:'a seq) = Seq.min xs

/// <summary>
/// Returns the lowest of all elements of the seq, compared via Operators.min on the function result.
/// Throws if <c>xs</c> has no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.minBySafe or Seq.minBy' instead.", 12101, IsHidden=true, IsError=false)>]
let inline minBy<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs:'a seq) = Seq.minBy projection xs

/// <summary>
/// Applies the given function to successive elements, returning the first
/// result where the function returns "Some(x)".
/// Throws if no such element exists.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.pickSafe or Seq.pick' instead.", 12101, IsHidden=true, IsError=false)>]
let inline pick chooser xs = Seq.pick chooser xs

/// <summary>
/// Applies a function to each element of the seq, threading an accumulator argument
/// through the computation. Begin by applying the function to the first two elements.
/// Then feed this result into the function along with the third element and so on.
/// Return the final result.
/// Throws if the seq is empty.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.reduce' or Seq.fold instead.", 12101, IsHidden=true, IsError=false)>]
let inline reduce reduction xs = Seq.reduce reduction xs

/// <summary>
/// Applies a function to each element of the seq, starting from the end, threading an accumulator argument
/// through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c>
/// then computes <c>f i0 (...(f iN-1 iN))</c>.
/// Throws if the seq is empty.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.reduceBack' or Seq.foldBack instead.", 12101, IsHidden=true, IsError=false)>]
let inline reduceBack reduction xs = Seq.reduceBack reduction xs 

/// <summary>
/// Returns a seq that skips N elements of the underlying seq and then yields the
/// remaining elements of the seq.
/// Throws if <c>count</c> exceeds the length of <c>xs</c> 
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.skip' or Seq.skipLenient instead.", 12101, IsHidden=true, IsError=false)>]
let inline skip count xs = Seq.skip count xs

/// <summary>
/// Splits the input seq into at most count chunks.
/// Throws if <c>count</c> is not positive.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.splitInto' or Seq.splitIntoN instead.", 12101, IsHidden=true, IsError=false)>]
let inline splitInto count xs = Seq.splitInto count xs

/// <summary>
/// Returns a seq that skips 1 element of the underlying seq and then yields the
/// remaining elements of the seq.
/// Throws if <c>xs</c> contains no elements.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.tailSafe or Seq.tail' instead.", 12101, IsHidden=true, IsError=false)>]
let inline tail xs = Seq.tail xs

/// <summary>
/// Returns the first N elements of the seq.
/// Throws if <c>count</c> exceeds the length of <c>xs</c> 
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.take' or Seq.truncate instead.", 12101, IsHidden=true, IsError=false)>]
let inline take count xs = Seq.take count xs

/// <summary>
/// Returns a seq that yields sliding windows containing elements drawn from the input
/// seq. Each window is returned as a fresh seq.
/// Throws when <c>size</c> is not positive.
/// </summary>
[<CompilerMessage("This is a partial function.  Use Seq.windowed' or Seq.window instead.", 12101, IsHidden=true, IsError=false)>]
let inline windowed size xs = Seq.windowed size xs
